# Шедеврооптимизации
> тут будут всеми известные темки по оптимайзу

> Автор не преподносит это как абсолютную истину, поэтому если есть возражения или предложения мяукните куда-нибудь, где я смогу это увидеть >w<
---

## Оглавление
1. [прагмочки](#1-прагмочки)
2. [ввод/вывод](#2-вводввывод)
3. [стат массивы](#3-стат-массивы)
4. [map/unordered_map](#4-mapunordered_map)
5. [умножение/деление/взятие по модулю на 2](#5-умножениеделениевзятие-по-модулю-на-2)
6. [порядок перебора](#6-порядок-перебора)
7. [лонги](#7-define-int-int64_t)
8. [unroll loops](#8-unroll-loops)
9. [переопределение аллокатора](#9-переопределение-аллокатора)
10. [приорити кью](#10-priority_queue)
11. [модульная арифметика](#11-модульная-арифметика)
12. [дерево отрезков](#12-дерево-отрезков)

### 1. прагмочки
Тут я лично юзаю ```#pragma GCC optimize("O3,unroll-loops")``` и ```#pragma GCC target("avx2")```.
За подробностями [сюда](https://codeforces.com/blog/entry/129283).
Для примера возьмем такой код:

```
#include <bits/stdc++.h>
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2")
using namespace std;

const int N = 2e9;

int32_t main() {
    int val = 0;
    for (int i = 0; i < N; i++)
        val += i & 1;
    cout << val;
}
```
| вариант          | время      |
|------------------|------------|
| Время без прагм  | 3.44 secs  |
| Время с прагмами | 104 millis |

> тут я видимо обосрался, и компиль как-то слишком по умному забустил прогу. Обыно не так сильно ускоряется.

### 2. ввод/ввывод
Порой ввод вывод данных может требовать очень много времени, поэтому для ускорения потоков ввода и вывода можете прописать эту строчку: ```cin.tie(0)->sync_with_stdio(0)```.

Для примера глянем на этот код:

```
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6;

int32_t main() {
    cin.tie(0)->sync_with_stdio(0);
    int res = 0;
    for (int i = 0; i < N; i++) {
        int x; cin >> x;
        res = max(res, x);
    }
    cout << res;
}
```

| вариант         | время     |
|-----------------|---------- |
|время с cin.tie  | 45 millis |
|время без cin.tie| 140 millis|

### 3. стат массивы
Стат массивы работают быстрее векторов. И местами это может зарешать. Еще если вектор используется как стек, то можно использовать статмассив с индексом его конца.

```
#include <bits/stdc++.h>
using namespace std;

const int N = 1e8;

// int a[N];

int32_t main() {
    vector<int> a(N);
    for (int i = 0; i < N; i++)
        a[i] = i;
    cout << a[1];
}
```
| вариант               | время     |
|-----------------------|---------- |
|время со статмассивом  | 385 millis|
|время с вектором       | 550 millis|


### 4. map/unordered_map

#### 4.1 чо можно юзать
Если мапа долго работает, то можно свапнуть на юмапу. Также ускорить работу юмапы можно с помощью ```mp.reserve(MAX_N)```.
Еще не стоит забывать про существование gp_hash_table. Подключить его можно так:
```
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
```

Стоит помнить, что можно сжимать числа, порой это может быть хорошим вариантом. Запихиваете все числа в вектор, а потом пишите:
```
a.sort(a.begin(), a.end()); // сортим вектор
a.erase(unique(a.begin(), a.end()), a.end()); // удаляем повторки
```

чтобы получить индекс в отсортированом массиве можно написать: ```lower_bound(a.begin(), a.end(), x) - a.begin()```


```
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6;

int32_t main() {
    unordered_map<int, int> mp;
    mp.reserve(N);
    for (int i = 0; i < N; i++)
        mp[i] = i;
    
    int mx = 0;

    for (int i = 0; i < N; i++)
        mx = max(mx, mp[i]);

    cout << mx;
}
```
|map|unordered_map|unordered_map + reserve | gp_hash_table |сжатие|
|---|-------------|------------------------|---------------|------|
|611|199          |149                     |145            |261   |


#### 4.2 если надо проверить на наличие ключа

```
int32_t main() {
    map<int, int> mp;
    for (int i = 0; i < 2 * N; i += 2)
        mp[i] = rnd();

    int cnt = 0;

    for (int i = 0; i < 2 * N; i++)
        if (mp.find(i) != mp.end())
            cnt++;

    cout << cnt;
}
```

Если юзать mp.find(x), вместо того чтобы каждый раз mp[x] вызывать, то можно ускорить прогу:
| mp[x] | mp.find(x) != mp.end() |
|-------|------------------------|
|1.33s  |0.99s                   |

пример на реальной задаче от некого Егора:  
ТЛ: https://codeforces.com/contest/1822/submission/311452284  
ОК: https://codeforces.com/contest/1822/submission/311452644  

#### 4.3 свой хеш для юмапы
```
struct pair_hash {
    inline size_t operator()(const pair<int, int>& v) const {
        return v.first * INF + v.second;
    }
};

unordered_set <pll, pair_hash> banned;
```

вот таким образом можете бахнуть свой хеш.

### 5. умножение/деление/взятие по модулю на 2
умножить на 2: << 1  
поделить на 2: >> 1  
взять по модулю 2: & 1

> оказалось, что первые 2 не сильно отличались, а вот модуль ускорял

```
#include <bits/stdc++.h>
using namespace std;

const int N = 2e9;

int32_t main() {
    int res = 0;
    for (int i = 0; i < N; i++)
        res += i % 2;
    cout << res;    
}
```

| %2  | & 1   |
|-----|-------|
|3.99s| 3.41s |

### 6. порядок перебора
Если в матрице сначала перебирать строки потом столбцы, то это будет быстрее, чем сначала столбцы, а потом строки.

```
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5, M = 1e3;

int a[N][M];

int32_t main() {
    int res = 0;
    
    for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++)
            res &= a[i][j];
    cout << res;
}
```

|сначала i потом j| сначала j потом i |
|-----------------|-------------------|
|656ms            |1.49s              |

### 7. #define int int64_t
Тесты показали, что они не сильно влияют на скорость. Однако в зависимости от компиля разница может быть значительной, поэтому лучше держать это в голове. Ну и память в 2 раза больше хавают.

### 8. unroll loops
Можно разворачивать циклы руками... Да да я понимаю, что это звучит дико. Но у меня был моментик когда прагма ничего не делала, поэтому можно иногда самим ручками разворачивать циклы.

Например вот это у меня Окнулось

```
int fi = (a[i][0] < a[j][0]) + 
            (a[i][1] < a[j][1]) +
                (a[i][2] < a[j][2]) + 
                    (a[i][3] < a[j][3]) + 
                        (a[i][4] < a[j][4]);
```

А это словило ТЛ10

```
int fi = 0;
for (int z = 0; z < 5; z++) {
    fi += (a[i][z] < a[j][z]);
}
```

Также есть хайповая прагма `#pragma GCC unroll 4`
```
int fi = 0;
#pragma GCC unroll 4
for (int z = 0; z < 5; z++) {
    fi += (a[i][z] < a[j][z]);
}
```

но она тоже ловит ТЛ10, однако на предыдущих тестах была быстрее.

|Ручками|Без прагмы|С прагмой|
|-------|----------|---------|
|537ms  |616ms     |558ms    |

### 9. переопределение аллокатора
можно переопределить new и delete, чтобы ускорить вашу программу. Однако стоит помнить, что данный мув памяти будет есть немало. Подробнее [здесь](https://algorithmica.org/ru/no-deallocation)

Вот читерский шаблон:
```
const int MAX_MEM = 4e8;
int mpos = 0;
alignas(long long) char mem[MAX_MEM];
inline void * operator new(size_t n) {
    if (n & 7) n += 8 - (n & 7);
    char *res = mem + mpos;
    mpos += n;
    return (void *)res;
}
void operator delete(void *) {}
```

Глянем на этот пример:
```
#include <bits/stdc++.h>
using namespace std;


const int MAX_MEM = 4e8;
int mpos = 0;
alignas(long long) char mem[MAX_MEM];
inline void * operator new(size_t n) {
    if (n & 7) n += 8 - (n & 7);
    char *res = mem + mpos;
    mpos += n;
    return (void *)res;
}
void operator delete(void *) {}

const int N = 1e7;

int32_t main() {
    unordered_map<int, int> mp;
    for (int i = 0; i < N; i++)
        mp[i] = i / 2;
    cout << mp[0];
}
```

|без переопределения|с ним|
|-------------------|-----|
|2.10s              |1.66s|

### 10. priority_queue

Она позволяет искать макс/мин, пихать в множесво, удалять макс/мин.  
Работает быстрее сета, поэтому супер хайп.

по умолчанию оно работает на макс, чтобы перевести на минимум:
`priority_queue <int, vector<int>, greater<int>> pq;` 

### 11. модульная арифметика

#### 11.1 сумма, тут есть 2 варианта
```
int sum(int a, int b) { return (a + b) % M; }
```

И если вы точно знаете, что a и b всегда будут меньше M, то:

```
int sum(int a, int b) { a += b; return a - (a >= M) * M; }
```

> 2 вариант получился раза в 4 быстрее, поэтому думайте

#### 11.2 разность, тут тоже есть 2 варианта
Так как плюсы для отрицательных чисел просто берет по модулю и добавляет минус, то для правильного взятия по модулю надо к результату прибавить M и еще раз взять по модулю M.
```
int dif(int a, int b) { return ((a - b) % M + M) % M; }
```

И если вы точно знаете, что a и b всегда будут меньше M, то:

```
int dif(int a, int b) { a -= b; return a + (a < 0) * M; }
```

> тут тоже 2 вариант в неплохо так раз быстрее

#### 11.3 умножение 

У вас результат умножения может не поместиться в инты и тут есть 2 варианта.  
1 вариант: просто все считайте в лонгах
2 вариант:
```
int mul(int a, int b) { return 1ll * a * b % M; }
```
ну тут умножение в лонгах и далее кастуем инт.

### 12. Дерево отрезков

Смешная фишка:  
если вы используете 1 индексацию, то можно использовать побитки:  
`2 * m  =  m << 1`  
`2 * m + 1 = m << 1 | 1`  
при n 1e8, я получил 200мс разницы

#### 12.1 Оптимизация по памяти до сверху   
Хотите до не за 4n памяти, а за 2n?  
Достаточно поменять номера вершин детей, используйте такие индексы:  
Левое дитя `p + 1`  
Правое дитя `p + 2 * (m - l)`  
Уточнение: дерево отрезков будет в 0 индексации и на полуинтервалах, для отрезков надо для правого дитя писать `p + 2 * (m - l + 1)` (автор примерно никогда не писал на отрезках, но вроде это правда)  
Доказательство и нюансы останутся в качестве упражнения читателю.
#### 12.2 Фенвик
Фенвик просто летает, ультра хайп и пишется просто. Юзайте везде где можно.  
Рекомендую реализацию с алгоритмики с https://algorithmica.org/ru/fenwick.
#### 12.3 До снизу
Если у вас не заходит до сверху пишите снизу, вот тут почитайте подробнее https://peltorator.org/posts/down_segment_tree/  
Как я пишу(изменение в точке, максимум на отрезке):

```
int t[2 * N];

void upd(int id, int x) {
    id += N;
    t[id] = x;
    id /= 2;
    while (id)
        t[id] = max(t[2 * id], t[2 * id + 1]), id /= 2;
}

int get(int l, int r) {
    int res = INF;
    while (r - l > 1) {
        if (l & 1)
            res = max(res, t[l++]);
        if (r & 1)
            res = max(res, t[--r]);
        l /= 2, r /= 2;
    }
    return res;
}
```
Тут еще и кода меньше, чем в до сверху. Если у вас массовых нет, то вообще сказка. С ними конечно можно, но я не пробовал.
