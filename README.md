# Шедеврооптимизации
> тут будут всеми известные темки по оптимайзу
---

## Оглавление
1. [прагмочки](#1-прагмочки)
2. [ввод/вывод](#2-вводввывод)
3. [стат массивы](#3-стат-массивы)
4. [map/unordered_map](#4-mapunordered_map)
5. [умножение/деление/взятие по модулю на 2](#5-умножениеделениевзятие-по-модулю-на-2)
6. [порядок перебора](#6-порядок-перебора)
7. [лонги](#7-define-int-int64_t)

### 1. прагмочки
Тут я лично юзаю ```#pragma GCC optimize("O3,unroll-loops")``` и ```#pragma GCC target("avx2")```.
За подробностями [сюда](https://codeforces.com/blog/entry/129283).
Для примера возьмем такой код:

```
#include <bits/stdc++.h>
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2")
using namespace std;

const int N = 2e9;

int32_t main() {
    int val = 0;
    for (int i = 0; i < N; i++)
        val += i & 1;
    cout << val;
}
```
| вариант          | время      |
|------------------|------------|
| Время без прагм  | 3.44 secs  |
| Время с прагмами | 104 millis |


### 2. ввод/ввывод
Порой ввод вывод данных может требовать очень много времени, поэтому для ускорения потоков ввода и вывода можете прописать эту строчку: ```cin.tie(0)->sync_with_stdio(0)```.

Для примера глянем на этот код:

```
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6;

int32_t main() {
    cin.tie(0)->sync_with_stdio(0);
    int res = 0;
    for (int i = 0; i < N; i++) {
        int x; cin >> x;
        res = max(res, x);
    }
    cout << res;
}
```

| вариант         | время     |
|-----------------|---------- |
|время с cin.tie  | 45 millis |
|время без cin.tie| 140 millis|

### 3. стат массивы
Стат массивы работают быстрее векторов. И местами это может зарешать. Еще если вектор используется как стек, то можно использовать статмассив с индексом его конца.

```
#include <bits/stdc++.h>
using namespace std;

const int N = 1e8;

// int a[N];

int32_t main() {
    vector<int> a(N);
    for (int i = 0; i < N; i++)
        a[i] = i;
    cout << a[1];
}
```
| вариант               | время     |
|-----------------------|---------- |
|время со статмассивом  | 385 millis|
|время с вектором       | 550 millis|


### 4. map/unordered_map
Если мапа долго работает, то можно свапнуть на юмапу. Также ускорить работу юмапы можно с помощью ```mp.reserve(MAX_N)```.
Еще не стоит забывать про существование gp_hash_table. Подключить его можно так:
```
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
```

Стоит помнить, что можно сжимать числа, порой это может быть хорошим вариантом. Запихиваете все числа в вектор, а потом пишите:
```
a.sort(a.begin(), a.end()); // сортим вектор
a.erase(unique(a.begin(), a.end()), a.end()); // удаляем повторки
```

чтобы получить индекс в отсортированом массиве можно написать: ```lower_bound(a.begin(), a.end(), x) - a.begin()```


```
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6;

int32_t main() {
    unordered_map<int, int> mp;
    mp.reserve(N);
    for (int i = 0; i < N; i++)
        mp[i] = i;
    
    int mx = 0;

    for (int i = 0; i < N; i++)
        mx = max(mx, mp[i]);

    cout << mx;
}
```
|map|unordered_map|unordered_map + reserve | gp_hash_table |сжатие|
|---|-------------|------------------------|---------------|------|
|611|199          |149                     |145            |261   |

### 5. умножение/деление/взятие по модулю на 2
умножить на 2: << 1  
поделить на 2: >> 1  
взять по модулю 2: & 1

> оказалось, что первые 2 не сильно отличались, а вот модуль ускорял

```
#include <bits/stdc++.h>
using namespace std;

const int N = 2e9;

int32_t main() {
    int res = 0;
    for (int i = 0; i < N; i++)
        res += i % 2;
    cout << res;    
}
```

| %2  | & 1   |
|-----|-------|
|3.99s| 3.41s |

### 6. порядок перебора
Если в матрице сначала перебирать строки потом столбцы, то это будет быстрее, чем сначала столбцы, а потом строки.

```
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5, M = 1e3;

int a[N][M];

int32_t main() {
    int res = 0;
    
    for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++)
            res &= a[i][j];
    cout << res;
}
```

|сначала i потом j| сначала j потом i |
|-----------------|-------------------|
|656ms            |1.49s              |

### 7. #define int int64_t
Тесты показали, что они не сильно влияют на скорость. Однако в зависимости от компиля разница может быть значительной, поэтому лучше держать это в голове. Ну и память в 2 раза больше хавают.
